local NoClipCheck = {}

local function dist(v1: Vector3,v2: Vector3)
	return (v1-v2).Magnitude
end

-- local visualizeparts = {}
	
function NoClipCheck:Check(playerObj)
	local passed = true
	local returnMessage = ""
	local playerPhysics = playerObj.Physics
	local player = playerObj.Player

	local rootPos = playerPhysics.CurrentCFrame.Position
	local lastPos = playerPhysics.LastCFrame.Position


	local ignore = {}
	for _,player in pairs(game.Players:GetPlayers())do
		if player.Character then
			table.insert(ignore,player.Character)
		end
	end
	
	local raycastParameters = RaycastParams.new()
	raycastParameters.FilterDescendantsInstances = ignore
	raycastParameters.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParameters.IgnoreWater = true
	
	-- local function visualize()
	-- 	local part = Instance.new("Part")
	-- 	part.Anchored = true
	-- 	part.CFrame = CFrame.lookAt(lastPos, rootPos)
	-- 	part.Size = Vector3.new(0.5, 0.5,(rootPos-lastPos).Magnitude)
	-- 	part.Parent = workspace
	-- 	part.CanCollide = false

	-- 	table.insert(visualizeparts, part)
	-- 	task.delay(2, function()
	-- 		part:Destroy()
	-- 	end)
	-- end 
	-- visualize()
	-- for i,v in pairs(visualizeparts) do
	-- 	table.insert(ignore, v)
	-- end

	local result = workspace:Raycast(lastPos,(rootPos-lastPos).Unit * dist(lastPos,rootPos),raycastParameters)
	if result then 
		local Part = result.Instance
		if Part:IsA("BasePart") then
			if Part:CanCollideWith(playerPhysics.Head) then
				passed = false
			end			
		end

		if not passed then
			playerPhysics.IgnoreNextCFrame = true

			returnMessage = player.Name .."'s path went through a wall or something that isn't a descendant of another character. Part:"..Part:GetFullName()
		end
	end

	return passed,returnMessage
end

function NoClipCheck:Punish(playerObj)
	playerObj.Player.Character:SetPrimaryPartCFrame(playerObj.Physics.LastCFrame)
end

return NoClipCheck
