local RootFolder = script.Parent.Parent

local Lib = RootFolder.Lib
local Maid = require(Lib.Maid)
local Signal = require(Lib.Signal)

local Modules = RootFolder.Modules
local CharacterInfo = require(Modules.CharacterInfo)
local Debugger = require(Modules.Debugger)

local ChecksList = require(Modules.Checks)

local PlayerClass = {}
PlayerClass.__index = PlayerClass

local defaultPhysicsInfo = {
    ["LastStepped"] = tick(),
    ["SkipNextStep"] = false,
    ["LastTimeInAir"] = false,
    
    ["LastCFrame"] = nil,
    ["CurrentCFrame"] = nil,
}

function PlayerClass.new(player)
    local self = setmetatable({
        ["Player"] = player,
        ["PhysicsInfo"] = table.clone(defaultPhysicsInfo),
        ["CharacterInfo"] = CharacterInfo.create(player),

        ["OnFlagged"] = Signal.new(),
        ["__maid"] = Maid.new(),
    }, PlayerClass)

    self.__maid:GiveTask(player.CharacterAdded:Connect(function(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")

        humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function()
            self.PhysicsInfo.SkipNextStep = true
        end)

        humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
            self.PhysicsInfo.SkipNextStep = true
        end)
    end))

    return self
end

function PlayerClass:Step()
    local physicsInfo = self.PhysicsInfo
    local characterInfo = self.CharacterInfo

    self:PreStepUpdate()
    
    if physicsInfo.SkipNextStep or characterInfo.IsMissingCriticalPart then
        physicsInfo.SkipNextStep = false
        return
    end

    for name, exploit in pairs(ChecksList) do 
        local passed, message = exploit.Check(self)

        if not passed then 
            Debugger.Warn(string.format("[AntiExploitFramework]: %s failed a check: \n Check Name: %s \n Message from Check: %s", self.Player.Name, name, message), 1)
            self:ResetNetworkOwner(1)
            self.OnFlagged:Fire(message)
            exploit.Punish(self)
        end
    end

    self:PostStepUpdate()
end

function PlayerClass:PostStepUpdate()
    self.PhysicsInfo.LastStepped = tick()
end

function PlayerClass:UpdatePhysicsInfo()
    local physicsInfo = self.PhysicsInfo
    local characterInfo = self.CharacterInfo
    local isMissingCriticalPart = characterInfo.IsMissingCriticalPart

    if isMissingCriticalPart then
        self.PhysicsInfo = table.clone(defaultPhysicsInfo)
        return
    end
    
    local currentCFrame = characterInfo.RootPart.CFrame

    if not physicsInfo.CurrentCFrame or not physicsInfo.LastCFrame then
        physicsInfo.LastCFrame = currentCFrame
        physicsInfo.CurrentCFrame = currentCFrame
        return
    end

    local lastCFrame = physicsInfo.CurrentCFrame

    if (lastCFrame.Position - currentCFrame.Position).Magnitude < 1 then
        physicsInfo.SkipNextStep = true
        return
    end

    physicsInfo.LastCFrame = physicsInfo.CurrentCFrame
    physicsInfo.CurrentCFrame = currentCFrame
end

function PlayerClass:PreStepUpdate()
    self.CharacterInfo = CharacterInfo.create(self.Player)
    self:UpdatePhysicsInfo()
end

function PlayerClass:ResetNetworkOwner(duration: number)
    local character = self.CharacterInfo.CharacterModel

    for _, Part in pairs(character:GetDescendants()) do
        if Part:IsA("BasePart")then
            if Part:CanSetNetworkOwnership() then
                Part:SetNetworkOwner(nil)
            end
        end
    end
	task.delay(duration, function()
		for _, Part in pairs(character:GetDescendants()) do
			if Part:IsA("BasePart")then
				if Part:CanSetNetworkOwnership() then
					Part:SetNetworkOwner(game.Players:GetPlayerFromCharacter(character))
				end
			end
		end
	end)
end

function PlayerClass:Destroy()
    self.__maid:DoCleaning()
end

return PlayerClass