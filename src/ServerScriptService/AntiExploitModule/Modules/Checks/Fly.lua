local RootFolder = script.Parent.Parent.Parent

local Debugger = require(RootFolder.Modules.Debugger)
local MAX_SECONDS_IN_FLIGHT = 5

local FlyCheck = {}

local function broadInAirCheck(playerObj)
    local inAir = true

    local characterInfo = playerObj.CharacterInfo
    local characterModel = characterInfo.CharacterModel
    local rootPart = characterInfo.RootPart

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {characterModel}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = false
    raycastParams.RespectCanCollide = true

    local result = workspace:Raycast(
        rootPart.Position,
        Vector3.new(0, -1, 0) * 6,
        raycastParams
    )


    if result then 
        inAir = false
    end

    return inAir
end

local function inAirCheck(playerObj)
    local isInAir = true

    local characterInfo = playerObj.CharacterInfo
    local characterModel = characterInfo.CharacterModel
    local rootPart = characterInfo.RootPart
    local originPos = rootPart.Position

    local rad = Vector3.new(5, 5, 5)
    local searchRegion = Region3.new(originPos - rad, originPos + rad)

    local overlapParams = OverlapParams.new()
    overlapParams.FilterDescendantsInstances = {characterModel}
    overlapParams.FilterType = Enum.RaycastFilterType.Exclude
    overlapParams.RespectCanCollide = true

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {characterModel}
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.IgnoreWater = false
    raycastParams.RespectCanCollide = true

    for _, part in pairs(workspace:GetPartBoundsInRadius(originPos, 4, overlapParams)) do
        if part:CanCollideWith(characterInfo.HeadPart) then
            isInAir = false
            break
        end
    end
    
    --Checks for valid terrain
    local materials = workspace.Terrain:ReadVoxels(searchRegion:ExpandToGrid(4), 4)
    for _, x in ipairs(materials) do
        for _, y in ipairs(x) do
            for _, cell in ipairs(y) do
                if cell ~= Enum.Material.Air then
                    isInAir = false
                    break
                end
            end
        end
    end

    return isInAir
end

function FlyCheck.Check(playerObj)
    local passed = true
    local returnMessage = ""

    local player = playerObj.Player
    local physics = playerObj.PhysicsInfo
    local isInAir = false
   
    local failedBroadCheck = broadInAirCheck(playerObj)

    if failedBroadCheck then
        isInAir = inAirCheck(playerObj)
    end

    if isInAir then
        physics.LastTimeInAir = physics.LastTimeInAir or tick()
        local airTime = tick() - physics.LastTimeInAir

        if airTime > 3 then
            Debugger.Print(
                string.format("[FlyExploitChecker]: %s is in the air... %d seconds until he is punished for flying", playerObj.Player.Name, MAX_SECONDS_IN_FLIGHT - airTime),
                2
            )
        end

        if airTime > MAX_SECONDS_IN_FLIGHT then
            passed = false
			physics.SkipNextStep = true

			returnMessage = player.Name .." was in the air for longer than ".. tostring(MAX_SECONDS_IN_FLIGHT).." seconds..."
			physics.LastTimeInAir = false
        end
    else
        physics.LastTimeInAir = false
    end

    return passed, returnMessage
end

function FlyCheck.Punish(playerObj)
    playerObj.Player:LoadCharacter()
end

return FlyCheck